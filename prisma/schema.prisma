generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["relationJoins", "views"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["cron", "public"]
}

model Account {
  id                String  @id @default(cuid())
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@schema("public")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@schema("public")
}

model User {
  id                  Int                  @id @default(autoincrement())
  name                String?
  email               String?              @unique
  emailVerified       DateTime?
  image               String?
  currency            String               @default("USD")
  preferredLanguage   String               @default("")
  bankingId           String?
  obapiProviderId     String?
  accounts            Account[]
  friendBalances      Balance[]            @relation("FriendBalance")
  userBalances        Balance[]            @relation("UserBalance")
  cachedBankData      CachedBankData[]     @relation("UserCachedBankData")
  addedExpenses       Expense[]            @relation("AddedByUser")
  deletedExpenses     Expense[]            @relation("DeletedByUser")
  paidExpenses        Expense[]            @relation("PaidByUser")
  updatedExpenses     Expense[]            @relation("UpdatedByUser")
  expenseComments     ExpenseComment[]
  expenseParticipants ExpenseParticipant[]
  groups              Group[]
  groupFriendBalances GroupBalance[]       @relation("GroupFriendBalance")
  groupUserBalances   GroupBalance[]       @relation("GroupUserBalance")
  associatedGroups    GroupUser[]
  sessions            Session[]
  userBalanceViews    BalanceView[]        @relation("UserBalanceView")
  friendBalanceViews  BalanceView[]        @relation("FriendBalanceView")

  @@schema("public")
}

model CachedBankData {
  id              Int      @id @default(autoincrement())
  obapiProviderId String   @unique
  data            String
  userId          Int
  lastFetched     DateTime
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  user            User     @relation("UserCachedBankData", fields: [userId], references: [id], onDelete: Cascade)

  @@schema("public")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@schema("public")
}

model Balance {
  userId                Int
  currency              String
  friendId              Int
  amount                BigInt
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  importedFromSplitwise Boolean  @default(false)
  friend                User     @relation("FriendBalance", fields: [friendId], references: [id], onDelete: Cascade)
  user                  User     @relation("UserBalance", fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, currency, friendId])
  @@schema("public")
}

model Group {
  id                Int            @id @default(autoincrement())
  publicId          String         @unique
  name              String
  userId            Int
  defaultCurrency   String         @default("USD")
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  splitwiseGroupId  String?        @unique
  simplifyDebts     Boolean        @default(false)
  archivedAt        DateTime?
  expenses          Expense[]
  createdBy         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  groupBalances     GroupBalance[]
  groupUsers        GroupUser[]
  groupBalanceViews BalanceView[]

  @@schema("public")
}

model GroupUser {
  groupId Int
  userId  Int
  group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user    User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([groupId, userId])
  @@schema("public")
}

model GroupBalance {
  groupId   Int
  currency  String
  userId    Int
  firendId  Int
  amount    BigInt
  updatedAt DateTime @updatedAt
  friend    User     @relation("GroupFriendBalance", fields: [firendId], references: [id], onDelete: Cascade)
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user      User     @relation("GroupUserBalance", fields: [userId], references: [id], onDelete: Cascade)

  @@id([groupId, currency, firendId, userId])
  @@schema("public")
}

model Expense {
  paidBy              Int
  addedBy             Int
  name                String
  category            String
  amount              BigInt
  splitType           SplitType            @default(EQUAL)
  expenseDate         DateTime             @default(now())
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  currency            String
  fileKey             String?
  groupId             Int?
  deletedAt           DateTime?
  deletedBy           Int?
  updatedBy           Int?
  transactionId       String?
  recurrenceId        Int?
  id                  String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  otherConversion     String?              @unique @db.Uuid
  addedByUser         User                 @relation("AddedByUser", fields: [addedBy], references: [id], onDelete: Cascade)
  deletedByUser       User?                @relation("DeletedByUser", fields: [deletedBy], references: [id], onDelete: Cascade)
  group               Group?               @relation(fields: [groupId], references: [id], onDelete: Cascade)
  conversionTo        Expense?             @relation("CurrencyConversion", fields: [otherConversion], references: [id], onDelete: Cascade)
  conversionFrom      Expense?             @relation("CurrencyConversion")
  paidByUser          User                 @relation("PaidByUser", fields: [paidBy], references: [id], onDelete: Cascade)
  recurrence          ExpenseRecurrence?   @relation(fields: [recurrenceId], references: [id], onDelete: Cascade)
  updatedByUser       User?                @relation("UpdatedByUser", fields: [updatedBy], references: [id])
  expenseComments     ExpenseComment[]
  expenseParticipants ExpenseParticipant[]

  @@index([groupId])
  @@index([paidBy])
  @@schema("public")
}

model ExpenseParticipant {
  userId    Int
  amount    BigInt
  expenseId String  @db.Uuid
  expense   Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([expenseId, userId])
  @@schema("public")
}

model ExpenseComment {
  id          String   @id @default(cuid())
  comment     String
  createdById Int
  createdAt   DateTime @default(now())
  expenseId   String   @db.Uuid
  createdBy   User     @relation(fields: [createdById], references: [id], onDelete: Cascade)
  expense     Expense  @relation(fields: [expenseId], references: [id], onDelete: Cascade)

  @@schema("public")
}

model ExpenseRecurrence {
  id       Int       @id @default(autoincrement())
  jobId    BigInt    @unique
  notified Boolean   @default(true)
  expense  Expense[]
  job      job       @relation(fields: [jobId], references: [jobid], onDelete: Cascade)

  @@schema("public")
}

model CurrencyRateCache {
  from       String
  to         String
  date       DateTime
  rate       Float
  insertedAt DateTime @default(now())

  @@id([from, to, date])
  @@schema("public")
}

model PushNotification {
  userId       Int    @id
  subscription String

  @@schema("public")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model job {
  jobid      BigInt             @id @default(autoincrement())
  schedule   String
  command    String
  nodename   String             @default("localhost")
  nodeport   Int                @default(dbgenerated("inet_server_port()"))
  database   String             @default(dbgenerated("current_database()"))
  username   String             @default(dbgenerated("CURRENT_USER"))
  active     Boolean            @default(true)
  jobname    String?
  recurrence ExpenseRecurrence? @relation()
  runDetails job_run_details[]  @relation("job_run_details")

  @@unique([jobname, username], map: "jobname_username_uniq")
  @@schema("cron")
}

/// This model contains row level security and requires additional setup for migrations. Visit https://pris.ly/d/row-level-security for more info.
model job_run_details {
  jobid          BigInt?
  runid          BigInt    @id @default(autoincrement())
  job_pid        Int?
  database       String?
  username       String?
  command        String?
  status         String?
  return_message String?
  start_time     DateTime? @db.Timestamptz(6)
  end_time       DateTime? @db.Timestamptz(6)

  job job? @relation("job_run_details", fields: [jobid], references: [jobid], onDelete: Cascade)

  @@schema("cron")
}

/// Unified balance view that calculates balances from expenses
/// Replaces both Balance and GroupBalance tables
view BalanceView {
  userId    Int
  friendId  Int
  groupId   Int?
  currency  String
  amount    BigInt
  createdAt DateTime
  updatedAt DateTime

  user   User   @relation("UserBalanceView", fields: [userId], references: [id], onDelete: Cascade)
  friend User   @relation("FriendBalanceView", fields: [friendId], references: [id], onDelete: Cascade)
  group  Group? @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@schema("public")
}

enum SplitType {
  EQUAL
  PERCENTAGE
  EXACT
  SHARE
  ADJUSTMENT
  SETTLEMENT
  CURRENCY_CONVERSION

  @@schema("public")
}
